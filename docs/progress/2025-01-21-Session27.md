# Session 27 - Supabase Phase 4 Testing & Debugging (2025-01-21)

## Status: Phase 4 In Progress (Upload Working ✅, Query Broken ❌)

## What We Accomplished

### 1. Fixed Stale Closure Bug in Upload Agent
**Problem**: Terminal logs showed `backend: file_search` despite Supabase being selected in UI.

**Root Cause**: `processQueue()` had empty dependency array, capturing initial `selectedBackend` value.

**Fix**: Used ref pattern (lines 72, 79-82 in `upload-agent.tsx`):
```typescript
const selectedBackendRef = useRef<"file_search" | "supabase">(selectedBackend);

useEffect(() => {
  selectedBackendRef.current = selectedBackend;
}, [selectedBackend]);

// Use in API calls:
backend: selectedBackendRef.current, // Instead of selectedBackend
```

### 2. Fixed Embedding Dimension Mismatch
**Problem**: Upload failed with "expected 1536 dimensions, not 768"

**Investigation**: User researched Gemini embedding models and found:
- `text-embedding-004`: Fixed 768 dimensions only
- `gemini-embedding-001`: Configurable 128-3072 dimensions
- **Critical**: `text-embedding-004` has Japanese tokenization instability issues

**Decision**: Use `gemini-embedding-001` @ 768 dimensions for:
- Stable Japanese tokenization (critical for TRS corpus)
- Lower storage costs vs 1536 dimensions
- Sufficient semantic accuracy for RAG

**Changes**:
1. Database schema: `ALTER TABLE chunks ALTER COLUMN embedding TYPE vector(768);`
2. Updated `lib/supabase-rag.ts` (lines 146-172):
   - Model: `gemini-embedding-001`
   - Config: `outputDimensionality: 768`
   - Task type: `RETRIEVAL_DOCUMENT` / `RETRIEVAL_QUERY`

### 3. Updated to @google/genai v1.29.0 SDK
**Problem**: Using wrong package `@google/generative-ai` (legacy)

**Fix**: Updated imports and API structure in `lib/supabase-rag.ts`:
```typescript
// OLD:
import { GoogleGenerativeAI } from '@google/generative-ai';
const genAI = new GoogleGenerativeAI(process.env.GOOGLE_AI_API_KEY!);

// NEW:
import { GoogleGenAI } from '@google/genai';
const ai = new GoogleGenAI({ apiKey: process.env.GOOGLE_AI_API_KEY! });

// NEW API:
const result = await ai.models.embedContent({
  model: 'gemini-embedding-001',
  contents: [{ parts: [{ text }] }],
  config: {
    outputDimensionality: 768,
    taskType: taskType
  }
});
```

### 4. Implemented Transaction Support
**Problem**: Orphaned documents from failed uploads caused duplicate key errors.

**Fix**: Added to `lib/supabase-rag.ts` `storeDocument()` (lines 212-320):

**1. Duplicate Detection (lines 212-236)**:
```typescript
const { data: existingDoc } = await supabase
  .from('documents')
  .select('id')
  .eq('citation_key', citationKey)
  .maybeSingle();

if (existingDoc) {
  await supabase.from('documents').delete().eq('id', existingDoc.id);
  console.log(`✓ Cleaned up orphaned document ${citationKey}`);
}
```

**2. Rollback on Failure (lines 304-320)**:
```typescript
try {
  // Insert all chunks...
} catch (chunkError) {
  console.error('❌ Chunk insertion failed, rolling back document...');
  await supabase.from('documents').delete().eq('id', doc.id);
  console.log(`✓ Rolled back document ${citationKey}`);
  throw chunkError;
}
```

### 5. Fixed Browse Tab Backend Filtering
**Problem**: Browse tab showed 244 documents (mixing File Search + Supabase).

**Root Cause**: `/api/corpus/list` didn't return `storageBackend` field (line 93 missing).

**Fix**:
1. Added `storageBackend: doc.storageBackend` to API response
2. Added backend filtering logic to `browse-query-agent.tsx` (lines 102-106)
3. Added RadioGroup UI selector to Browse Documents tab (lines 314-350)

**Result**: Browse tab now correctly separates:
- File Search Store: 241 documents
- Supabase: 1 document (Braid test upload)

### 6. Fixed Delete Endpoint for Supabase
**Problem**: Delete endpoint didn't handle Supabase documents.

**Fix**: Added Supabase deletion path to `app/api/corpus/delete/route.ts` (lines 54-63):
```typescript
if (doc.storageBackend === 'supabase') {
  await deleteFromSupabase(doc.fileId);
  deletionResults.fileSearch = true; // Reuse field
  console.log(`✅ Deleted from Supabase: ${doc.fileId}`);
}
```

### 7. Cleaned Up Duplicate Braid Documents
**Action**: Deleted 2 duplicate Braid documents from File Search Store, keeping only:
- "Braid Super Mechatronics 技術資料 (Technical Material)" (Nov 21, 2:16 AM upload)

**Result**: File Search corpus reduced from 243 → 241 documents.

---

## Current Problem: Supabase RAG Query Not Working ❌

### Symptoms
1. ✅ **Upload succeeds**: Document stored in Supabase with 768-dim embeddings
2. ✅ **Browse shows document**: Appears in Supabase backend filter
3. ❌ **Query fails**: Returns "I apologize, but I do not have a database..." (generic non-answer)

### Example Query
**Input**: "give me an example from your database"

**Expected**: Should retrieve Braid Super Mechatronics document about measurement devices

**Actual**: Generic response saying "I do not have a database in the sense of a collection of examples..."

### Investigation Needed (Next Session)
1. **Check chunks table**: Are chunks actually stored?
   ```sql
   SELECT COUNT(*), document_id FROM chunks GROUP BY document_id;
   ```

2. **Test search function directly**:
   ```sql
   SELECT * FROM search_chunks(
     query_embedding := (SELECT embedding FROM chunks LIMIT 1),
     match_threshold := 0.5,
     match_count := 10,
     filter_quality_tiers := NULL
   );
   ```

3. **Check similarity scores**: Are embeddings generating valid results?
4. **Verify API endpoint**: Is `/api/summary` calling Supabase search correctly?
5. **Check Gemini response**: Is the AI interpreting empty results correctly?

---

## Technical Learnings

### Embedding Model Selection for Japanese Text
**Research Findings** (User-provided):
- **text-embedding-004**:
  - Fixed 768 dimensions
  - Reported instability with Japanese tokenization
  - Cheaper but risky for multilingual corpus

- **gemini-embedding-001**:
  - Configurable dimensions (128-3072)
  - Stable Japanese tokenization
  - Matryoshka Representation Learning support
  - Recommended for production multilingual RAG

**Decision**: Use `gemini-embedding-001` @ 768 dimensions for TRS corpus.

### React Closure Bug Pattern
**Problem**: Functions with empty dependency arrays capture stale state.

**Solution**: Use refs to access current state:
```typescript
const stateRef = useRef(initialState);

useEffect(() => {
  stateRef.current = state; // Sync ref with state
}, [state]);

// In function with empty deps:
someFunction(() => {
  console.log(stateRef.current); // Always current value
});
```

### Transaction Pattern for PostgreSQL
**Pattern**: Duplicate detection + rollback on partial failure:
1. Check for existing document (by unique key)
2. Delete existing if found (cascading deletes handle related data)
3. Insert new document
4. Try inserting related data (chunks)
5. If step 4 fails, rollback step 3

**Why not use BEGIN/COMMIT?** Supabase client auto-commits each query. This pattern achieves same result with explicit cleanup.

---

## Files Modified

1. `components/agents/upload-agent.tsx` - Fixed stale closure bug
2. `lib/supabase-rag.ts` - Fixed embeddings, SDK, transactions
3. `app/api/corpus/list/route.ts` - Added storageBackend field
4. `app/api/corpus/delete/route.ts` - Added Supabase deletion
5. `components/agents/browse-query-agent.tsx` - Added backend filtering

---

## Metrics

- **File Search Corpus**: 241 documents (cleaned up from 243)
- **Supabase Test Corpus**: 1 document (Braid Super Mechatronics)
- **Build Status**: ✅ 0 TypeScript errors
- **Upload Status**: ✅ Working (both backends)
- **Query Status**: ✅ File Search working | ❌ Supabase broken

---

## Next Session Priority

**URGENT**: Debug Supabase RAG query failure before proceeding with Phase 4 comparison.

**Investigation Steps**:
1. Verify chunks are in database
2. Test search function directly in Supabase SQL editor
3. Check similarity scores
4. Verify `/api/summary` Supabase path
5. Test with known relevant query about measurement technology

**Goal**: Get at least one successful RAG query from Supabase before comparing quality with File Search Store.
